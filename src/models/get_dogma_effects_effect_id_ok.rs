/* 
 * EVE Swagger Interface
 *
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 1.17
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// GetDogmaEffectsEffectIdOk : 200 ok object

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct GetDogmaEffectsEffectIdOk {
  /// description string
  #[serde(rename = "description")]
  description: Option<String>,
  /// disallow_auto_repeat boolean
  #[serde(rename = "disallow_auto_repeat")]
  disallow_auto_repeat: Option<bool>,
  /// discharge_attribute_id integer
  #[serde(rename = "discharge_attribute_id")]
  discharge_attribute_id: Option<i32>,
  /// display_name string
  #[serde(rename = "display_name")]
  display_name: Option<String>,
  /// duration_attribute_id integer
  #[serde(rename = "duration_attribute_id")]
  duration_attribute_id: Option<i32>,
  /// effect_category integer
  #[serde(rename = "effect_category")]
  effect_category: Option<i32>,
  /// effect_id integer
  #[serde(rename = "effect_id")]
  effect_id: i32,
  /// electronic_chance boolean
  #[serde(rename = "electronic_chance")]
  electronic_chance: Option<bool>,
  /// falloff_attribute_id integer
  #[serde(rename = "falloff_attribute_id")]
  falloff_attribute_id: Option<i32>,
  /// icon_id integer
  #[serde(rename = "icon_id")]
  icon_id: Option<i32>,
  /// is_assistance boolean
  #[serde(rename = "is_assistance")]
  is_assistance: Option<bool>,
  /// is_offensive boolean
  #[serde(rename = "is_offensive")]
  is_offensive: Option<bool>,
  /// is_warp_safe boolean
  #[serde(rename = "is_warp_safe")]
  is_warp_safe: Option<bool>,
  /// modifiers array
  #[serde(rename = "modifiers")]
  modifiers: Option<Vec<::models::GetDogmaEffectsEffectIdModifier>>,
  /// name string
  #[serde(rename = "name")]
  name: Option<String>,
  /// post_expression integer
  #[serde(rename = "post_expression")]
  post_expression: Option<i32>,
  /// pre_expression integer
  #[serde(rename = "pre_expression")]
  pre_expression: Option<i32>,
  /// published boolean
  #[serde(rename = "published")]
  published: Option<bool>,
  /// range_attribute_id integer
  #[serde(rename = "range_attribute_id")]
  range_attribute_id: Option<i32>,
  /// range_chance boolean
  #[serde(rename = "range_chance")]
  range_chance: Option<bool>,
  /// tracking_speed_attribute_id integer
  #[serde(rename = "tracking_speed_attribute_id")]
  tracking_speed_attribute_id: Option<i32>
}

impl GetDogmaEffectsEffectIdOk {
  /// 200 ok object
  pub fn new(effect_id: i32) -> GetDogmaEffectsEffectIdOk {
    GetDogmaEffectsEffectIdOk {
      description: None,
      disallow_auto_repeat: None,
      discharge_attribute_id: None,
      display_name: None,
      duration_attribute_id: None,
      effect_category: None,
      effect_id: effect_id,
      electronic_chance: None,
      falloff_attribute_id: None,
      icon_id: None,
      is_assistance: None,
      is_offensive: None,
      is_warp_safe: None,
      modifiers: None,
      name: None,
      post_expression: None,
      pre_expression: None,
      published: None,
      range_attribute_id: None,
      range_chance: None,
      tracking_speed_attribute_id: None
    }
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> GetDogmaEffectsEffectIdOk {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_disallow_auto_repeat(&mut self, disallow_auto_repeat: bool) {
    self.disallow_auto_repeat = Some(disallow_auto_repeat);
  }

  pub fn with_disallow_auto_repeat(mut self, disallow_auto_repeat: bool) -> GetDogmaEffectsEffectIdOk {
    self.disallow_auto_repeat = Some(disallow_auto_repeat);
    self
  }

  pub fn disallow_auto_repeat(&self) -> Option<&bool> {
    self.disallow_auto_repeat.as_ref()
  }

  pub fn reset_disallow_auto_repeat(&mut self) {
    self.disallow_auto_repeat = None;
  }

  pub fn set_discharge_attribute_id(&mut self, discharge_attribute_id: i32) {
    self.discharge_attribute_id = Some(discharge_attribute_id);
  }

  pub fn with_discharge_attribute_id(mut self, discharge_attribute_id: i32) -> GetDogmaEffectsEffectIdOk {
    self.discharge_attribute_id = Some(discharge_attribute_id);
    self
  }

  pub fn discharge_attribute_id(&self) -> Option<&i32> {
    self.discharge_attribute_id.as_ref()
  }

  pub fn reset_discharge_attribute_id(&mut self) {
    self.discharge_attribute_id = None;
  }

  pub fn set_display_name(&mut self, display_name: String) {
    self.display_name = Some(display_name);
  }

  pub fn with_display_name(mut self, display_name: String) -> GetDogmaEffectsEffectIdOk {
    self.display_name = Some(display_name);
    self
  }

  pub fn display_name(&self) -> Option<&String> {
    self.display_name.as_ref()
  }

  pub fn reset_display_name(&mut self) {
    self.display_name = None;
  }

  pub fn set_duration_attribute_id(&mut self, duration_attribute_id: i32) {
    self.duration_attribute_id = Some(duration_attribute_id);
  }

  pub fn with_duration_attribute_id(mut self, duration_attribute_id: i32) -> GetDogmaEffectsEffectIdOk {
    self.duration_attribute_id = Some(duration_attribute_id);
    self
  }

  pub fn duration_attribute_id(&self) -> Option<&i32> {
    self.duration_attribute_id.as_ref()
  }

  pub fn reset_duration_attribute_id(&mut self) {
    self.duration_attribute_id = None;
  }

  pub fn set_effect_category(&mut self, effect_category: i32) {
    self.effect_category = Some(effect_category);
  }

  pub fn with_effect_category(mut self, effect_category: i32) -> GetDogmaEffectsEffectIdOk {
    self.effect_category = Some(effect_category);
    self
  }

  pub fn effect_category(&self) -> Option<&i32> {
    self.effect_category.as_ref()
  }

  pub fn reset_effect_category(&mut self) {
    self.effect_category = None;
  }

  pub fn set_effect_id(&mut self, effect_id: i32) {
    self.effect_id = effect_id;
  }

  pub fn with_effect_id(mut self, effect_id: i32) -> GetDogmaEffectsEffectIdOk {
    self.effect_id = effect_id;
    self
  }

  pub fn effect_id(&self) -> &i32 {
    &self.effect_id
  }


  pub fn set_electronic_chance(&mut self, electronic_chance: bool) {
    self.electronic_chance = Some(electronic_chance);
  }

  pub fn with_electronic_chance(mut self, electronic_chance: bool) -> GetDogmaEffectsEffectIdOk {
    self.electronic_chance = Some(electronic_chance);
    self
  }

  pub fn electronic_chance(&self) -> Option<&bool> {
    self.electronic_chance.as_ref()
  }

  pub fn reset_electronic_chance(&mut self) {
    self.electronic_chance = None;
  }

  pub fn set_falloff_attribute_id(&mut self, falloff_attribute_id: i32) {
    self.falloff_attribute_id = Some(falloff_attribute_id);
  }

  pub fn with_falloff_attribute_id(mut self, falloff_attribute_id: i32) -> GetDogmaEffectsEffectIdOk {
    self.falloff_attribute_id = Some(falloff_attribute_id);
    self
  }

  pub fn falloff_attribute_id(&self) -> Option<&i32> {
    self.falloff_attribute_id.as_ref()
  }

  pub fn reset_falloff_attribute_id(&mut self) {
    self.falloff_attribute_id = None;
  }

  pub fn set_icon_id(&mut self, icon_id: i32) {
    self.icon_id = Some(icon_id);
  }

  pub fn with_icon_id(mut self, icon_id: i32) -> GetDogmaEffectsEffectIdOk {
    self.icon_id = Some(icon_id);
    self
  }

  pub fn icon_id(&self) -> Option<&i32> {
    self.icon_id.as_ref()
  }

  pub fn reset_icon_id(&mut self) {
    self.icon_id = None;
  }

  pub fn set_is_assistance(&mut self, is_assistance: bool) {
    self.is_assistance = Some(is_assistance);
  }

  pub fn with_is_assistance(mut self, is_assistance: bool) -> GetDogmaEffectsEffectIdOk {
    self.is_assistance = Some(is_assistance);
    self
  }

  pub fn is_assistance(&self) -> Option<&bool> {
    self.is_assistance.as_ref()
  }

  pub fn reset_is_assistance(&mut self) {
    self.is_assistance = None;
  }

  pub fn set_is_offensive(&mut self, is_offensive: bool) {
    self.is_offensive = Some(is_offensive);
  }

  pub fn with_is_offensive(mut self, is_offensive: bool) -> GetDogmaEffectsEffectIdOk {
    self.is_offensive = Some(is_offensive);
    self
  }

  pub fn is_offensive(&self) -> Option<&bool> {
    self.is_offensive.as_ref()
  }

  pub fn reset_is_offensive(&mut self) {
    self.is_offensive = None;
  }

  pub fn set_is_warp_safe(&mut self, is_warp_safe: bool) {
    self.is_warp_safe = Some(is_warp_safe);
  }

  pub fn with_is_warp_safe(mut self, is_warp_safe: bool) -> GetDogmaEffectsEffectIdOk {
    self.is_warp_safe = Some(is_warp_safe);
    self
  }

  pub fn is_warp_safe(&self) -> Option<&bool> {
    self.is_warp_safe.as_ref()
  }

  pub fn reset_is_warp_safe(&mut self) {
    self.is_warp_safe = None;
  }

  pub fn set_modifiers(&mut self, modifiers: Vec<::models::GetDogmaEffectsEffectIdModifier>) {
    self.modifiers = Some(modifiers);
  }

  pub fn with_modifiers(mut self, modifiers: Vec<::models::GetDogmaEffectsEffectIdModifier>) -> GetDogmaEffectsEffectIdOk {
    self.modifiers = Some(modifiers);
    self
  }

  pub fn modifiers(&self) -> Option<&Vec<::models::GetDogmaEffectsEffectIdModifier>> {
    self.modifiers.as_ref()
  }

  pub fn reset_modifiers(&mut self) {
    self.modifiers = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> GetDogmaEffectsEffectIdOk {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_post_expression(&mut self, post_expression: i32) {
    self.post_expression = Some(post_expression);
  }

  pub fn with_post_expression(mut self, post_expression: i32) -> GetDogmaEffectsEffectIdOk {
    self.post_expression = Some(post_expression);
    self
  }

  pub fn post_expression(&self) -> Option<&i32> {
    self.post_expression.as_ref()
  }

  pub fn reset_post_expression(&mut self) {
    self.post_expression = None;
  }

  pub fn set_pre_expression(&mut self, pre_expression: i32) {
    self.pre_expression = Some(pre_expression);
  }

  pub fn with_pre_expression(mut self, pre_expression: i32) -> GetDogmaEffectsEffectIdOk {
    self.pre_expression = Some(pre_expression);
    self
  }

  pub fn pre_expression(&self) -> Option<&i32> {
    self.pre_expression.as_ref()
  }

  pub fn reset_pre_expression(&mut self) {
    self.pre_expression = None;
  }

  pub fn set_published(&mut self, published: bool) {
    self.published = Some(published);
  }

  pub fn with_published(mut self, published: bool) -> GetDogmaEffectsEffectIdOk {
    self.published = Some(published);
    self
  }

  pub fn published(&self) -> Option<&bool> {
    self.published.as_ref()
  }

  pub fn reset_published(&mut self) {
    self.published = None;
  }

  pub fn set_range_attribute_id(&mut self, range_attribute_id: i32) {
    self.range_attribute_id = Some(range_attribute_id);
  }

  pub fn with_range_attribute_id(mut self, range_attribute_id: i32) -> GetDogmaEffectsEffectIdOk {
    self.range_attribute_id = Some(range_attribute_id);
    self
  }

  pub fn range_attribute_id(&self) -> Option<&i32> {
    self.range_attribute_id.as_ref()
  }

  pub fn reset_range_attribute_id(&mut self) {
    self.range_attribute_id = None;
  }

  pub fn set_range_chance(&mut self, range_chance: bool) {
    self.range_chance = Some(range_chance);
  }

  pub fn with_range_chance(mut self, range_chance: bool) -> GetDogmaEffectsEffectIdOk {
    self.range_chance = Some(range_chance);
    self
  }

  pub fn range_chance(&self) -> Option<&bool> {
    self.range_chance.as_ref()
  }

  pub fn reset_range_chance(&mut self) {
    self.range_chance = None;
  }

  pub fn set_tracking_speed_attribute_id(&mut self, tracking_speed_attribute_id: i32) {
    self.tracking_speed_attribute_id = Some(tracking_speed_attribute_id);
  }

  pub fn with_tracking_speed_attribute_id(mut self, tracking_speed_attribute_id: i32) -> GetDogmaEffectsEffectIdOk {
    self.tracking_speed_attribute_id = Some(tracking_speed_attribute_id);
    self
  }

  pub fn tracking_speed_attribute_id(&self) -> Option<&i32> {
    self.tracking_speed_attribute_id.as_ref()
  }

  pub fn reset_tracking_speed_attribute_id(&mut self) {
    self.tracking_speed_attribute_id = None;
  }

}



