/* 
 * EVE Swagger Interface
 *
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 1.17
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// GetUniverseTypesTypeIdOk : 200 ok object

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct GetUniverseTypesTypeIdOk {
  /// capacity number
  #[serde(rename = "capacity")]
  capacity: Option<f32>,
  /// description string
  #[serde(rename = "description")]
  description: String,
  /// dogma_attributes array
  #[serde(rename = "dogma_attributes")]
  dogma_attributes: Option<Vec<::models::GetUniverseTypesTypeIdDogmaAttribute>>,
  /// dogma_effects array
  #[serde(rename = "dogma_effects")]
  dogma_effects: Option<Vec<::models::GetUniverseTypesTypeIdDogmaEffect>>,
  /// graphic_id integer
  #[serde(rename = "graphic_id")]
  graphic_id: Option<i32>,
  /// group_id integer
  #[serde(rename = "group_id")]
  group_id: i32,
  /// icon_id integer
  #[serde(rename = "icon_id")]
  icon_id: Option<i32>,
  /// This only exists for types that can be put on the market
  #[serde(rename = "market_group_id")]
  market_group_id: Option<i32>,
  /// mass number
  #[serde(rename = "mass")]
  mass: Option<f32>,
  /// name string
  #[serde(rename = "name")]
  name: String,
  /// packaged_volume number
  #[serde(rename = "packaged_volume")]
  packaged_volume: Option<f32>,
  /// portion_size integer
  #[serde(rename = "portion_size")]
  portion_size: Option<i32>,
  /// published boolean
  #[serde(rename = "published")]
  published: bool,
  /// radius number
  #[serde(rename = "radius")]
  radius: Option<f32>,
  /// type_id integer
  #[serde(rename = "type_id")]
  type_id: i32,
  /// volume number
  #[serde(rename = "volume")]
  volume: Option<f32>
}

impl GetUniverseTypesTypeIdOk {
  /// 200 ok object
  pub fn new(description: String, group_id: i32, name: String, published: bool, type_id: i32) -> GetUniverseTypesTypeIdOk {
    GetUniverseTypesTypeIdOk {
      capacity: None,
      description: description,
      dogma_attributes: None,
      dogma_effects: None,
      graphic_id: None,
      group_id: group_id,
      icon_id: None,
      market_group_id: None,
      mass: None,
      name: name,
      packaged_volume: None,
      portion_size: None,
      published: published,
      radius: None,
      type_id: type_id,
      volume: None
    }
  }

  pub fn set_capacity(&mut self, capacity: f32) {
    self.capacity = Some(capacity);
  }

  pub fn with_capacity(mut self, capacity: f32) -> GetUniverseTypesTypeIdOk {
    self.capacity = Some(capacity);
    self
  }

  pub fn capacity(&self) -> Option<&f32> {
    self.capacity.as_ref()
  }

  pub fn reset_capacity(&mut self) {
    self.capacity = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = description;
  }

  pub fn with_description(mut self, description: String) -> GetUniverseTypesTypeIdOk {
    self.description = description;
    self
  }

  pub fn description(&self) -> &String {
    &self.description
  }


  pub fn set_dogma_attributes(&mut self, dogma_attributes: Vec<::models::GetUniverseTypesTypeIdDogmaAttribute>) {
    self.dogma_attributes = Some(dogma_attributes);
  }

  pub fn with_dogma_attributes(mut self, dogma_attributes: Vec<::models::GetUniverseTypesTypeIdDogmaAttribute>) -> GetUniverseTypesTypeIdOk {
    self.dogma_attributes = Some(dogma_attributes);
    self
  }

  pub fn dogma_attributes(&self) -> Option<&Vec<::models::GetUniverseTypesTypeIdDogmaAttribute>> {
    self.dogma_attributes.as_ref()
  }

  pub fn reset_dogma_attributes(&mut self) {
    self.dogma_attributes = None;
  }

  pub fn set_dogma_effects(&mut self, dogma_effects: Vec<::models::GetUniverseTypesTypeIdDogmaEffect>) {
    self.dogma_effects = Some(dogma_effects);
  }

  pub fn with_dogma_effects(mut self, dogma_effects: Vec<::models::GetUniverseTypesTypeIdDogmaEffect>) -> GetUniverseTypesTypeIdOk {
    self.dogma_effects = Some(dogma_effects);
    self
  }

  pub fn dogma_effects(&self) -> Option<&Vec<::models::GetUniverseTypesTypeIdDogmaEffect>> {
    self.dogma_effects.as_ref()
  }

  pub fn reset_dogma_effects(&mut self) {
    self.dogma_effects = None;
  }

  pub fn set_graphic_id(&mut self, graphic_id: i32) {
    self.graphic_id = Some(graphic_id);
  }

  pub fn with_graphic_id(mut self, graphic_id: i32) -> GetUniverseTypesTypeIdOk {
    self.graphic_id = Some(graphic_id);
    self
  }

  pub fn graphic_id(&self) -> Option<&i32> {
    self.graphic_id.as_ref()
  }

  pub fn reset_graphic_id(&mut self) {
    self.graphic_id = None;
  }

  pub fn set_group_id(&mut self, group_id: i32) {
    self.group_id = group_id;
  }

  pub fn with_group_id(mut self, group_id: i32) -> GetUniverseTypesTypeIdOk {
    self.group_id = group_id;
    self
  }

  pub fn group_id(&self) -> &i32 {
    &self.group_id
  }


  pub fn set_icon_id(&mut self, icon_id: i32) {
    self.icon_id = Some(icon_id);
  }

  pub fn with_icon_id(mut self, icon_id: i32) -> GetUniverseTypesTypeIdOk {
    self.icon_id = Some(icon_id);
    self
  }

  pub fn icon_id(&self) -> Option<&i32> {
    self.icon_id.as_ref()
  }

  pub fn reset_icon_id(&mut self) {
    self.icon_id = None;
  }

  pub fn set_market_group_id(&mut self, market_group_id: i32) {
    self.market_group_id = Some(market_group_id);
  }

  pub fn with_market_group_id(mut self, market_group_id: i32) -> GetUniverseTypesTypeIdOk {
    self.market_group_id = Some(market_group_id);
    self
  }

  pub fn market_group_id(&self) -> Option<&i32> {
    self.market_group_id.as_ref()
  }

  pub fn reset_market_group_id(&mut self) {
    self.market_group_id = None;
  }

  pub fn set_mass(&mut self, mass: f32) {
    self.mass = Some(mass);
  }

  pub fn with_mass(mut self, mass: f32) -> GetUniverseTypesTypeIdOk {
    self.mass = Some(mass);
    self
  }

  pub fn mass(&self) -> Option<&f32> {
    self.mass.as_ref()
  }

  pub fn reset_mass(&mut self) {
    self.mass = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> GetUniverseTypesTypeIdOk {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_packaged_volume(&mut self, packaged_volume: f32) {
    self.packaged_volume = Some(packaged_volume);
  }

  pub fn with_packaged_volume(mut self, packaged_volume: f32) -> GetUniverseTypesTypeIdOk {
    self.packaged_volume = Some(packaged_volume);
    self
  }

  pub fn packaged_volume(&self) -> Option<&f32> {
    self.packaged_volume.as_ref()
  }

  pub fn reset_packaged_volume(&mut self) {
    self.packaged_volume = None;
  }

  pub fn set_portion_size(&mut self, portion_size: i32) {
    self.portion_size = Some(portion_size);
  }

  pub fn with_portion_size(mut self, portion_size: i32) -> GetUniverseTypesTypeIdOk {
    self.portion_size = Some(portion_size);
    self
  }

  pub fn portion_size(&self) -> Option<&i32> {
    self.portion_size.as_ref()
  }

  pub fn reset_portion_size(&mut self) {
    self.portion_size = None;
  }

  pub fn set_published(&mut self, published: bool) {
    self.published = published;
  }

  pub fn with_published(mut self, published: bool) -> GetUniverseTypesTypeIdOk {
    self.published = published;
    self
  }

  pub fn published(&self) -> &bool {
    &self.published
  }


  pub fn set_radius(&mut self, radius: f32) {
    self.radius = Some(radius);
  }

  pub fn with_radius(mut self, radius: f32) -> GetUniverseTypesTypeIdOk {
    self.radius = Some(radius);
    self
  }

  pub fn radius(&self) -> Option<&f32> {
    self.radius.as_ref()
  }

  pub fn reset_radius(&mut self) {
    self.radius = None;
  }

  pub fn set_type_id(&mut self, type_id: i32) {
    self.type_id = type_id;
  }

  pub fn with_type_id(mut self, type_id: i32) -> GetUniverseTypesTypeIdOk {
    self.type_id = type_id;
    self
  }

  pub fn type_id(&self) -> &i32 {
    &self.type_id
  }


  pub fn set_volume(&mut self, volume: f32) {
    self.volume = Some(volume);
  }

  pub fn with_volume(mut self, volume: f32) -> GetUniverseTypesTypeIdOk {
    self.volume = Some(volume);
    self
  }

  pub fn volume(&self) -> Option<&f32> {
    self.volume.as_ref()
  }

  pub fn reset_volume(&mut self) {
    self.volume = None;
  }

}



